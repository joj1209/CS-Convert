<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <!-- 페이지 제목: 오프라인에서 동작하는 간단한 변수 치환 도구 -->
  <title>변수 치환 도우미 (오프라인, 무스타일)</title>
</head>
<body>
  <!-- 입력 영역: 사용자가 변환하고자 하는 SQL 쿼리나 텍스트를 입력하는 공간 -->
  <h3>변경전 입력박스 (여기에 쿼리를 붙여넣으세요)</h3>
  <textarea id="inputQuery" rows="12" cols="120" placeholder="예) SELECT * FROM `SCHEMA`.`TAB_A` WHERE col = :old_var;"></textarea>

  <!-- 변수 매핑 영역: 변경 전/후 변수를 1:1로 매칭 -->
  <h3>변경전 변수 / 변경후 변수</h3>
  <p>같은 줄끼리 1:1 매칭합니다. (빈 줄은 무시)</p>
  <div>
    <!-- 좌측: 변경 전 변수 목록 입력 -->
    <div style="display:inline-block; vertical-align:top; margin-right:12px;">
      <div><strong>변경전 변수</strong></div>
      <textarea id="beforeVars" rows="10" cols="58" style="height:200px;">:OLD_VAR1
:OLD_VAR2
:OLD_VAR3
:OLD_VAR4
:OLD_VAR5
:TEMP_ID
:SRC_DATE
:SRC_NAME
:SRC_AMT
:SRC_FLAG
</textarea>
    </div>
    <!-- 우측: 변경 후 변수 목록 입력 (좌측과 같은 줄 번호끼리 매칭됨) -->
    <div style="display:inline-block; vertical-align:top;">
      <div><strong>변경후 변수</strong></div>
      <textarea id="afterVars" rows="10" cols="58" style="height:200px;">:NEW_VAR1
:NEW_VAR2
:NEW_VAR3
:NEW_VAR4
:NEW_VAR5
:USER_ID
:DST_DATE
:DST_NAME
:DST_AMT
:DST_FLAG
</textarea>
    </div>
  </div>

  <!-- 치환 옵션 설정 영역 -->
  <h4>옵션</h4>
  
  <!-- 옵션1: SQL 문자열 내부 치환 제외 (예: WHERE name = 'OLD_VAR1' 같은 경우 따옴표 안은 치환하지 않음) -->
  <label>
    <input type="checkbox" id="skipStrings" checked>
    따옴표 문자열( '...' ) 내부는 치환 건너뛰기
  </label>
  <br>
  
  <!-- 옵션2: 단어 경계 검사 활성화 (예: :OLD가 :OLD_VAR의 일부로 잘못 치환되는 것 방지) -->
  <label>
    <input type="checkbox" id="useWordBoundary" checked>
    식별자 경계 매칭(부분 문자열 오치환 방지)
  </label>
  <br>
  
  <!-- 옵션3: 대소문자 구분 여부 설정 -->
  <label>
    대소문자 구분:
    <select id="caseMode">
      <option value="sensitive">구분함</option>
      <option value="insensitive" selected>구분하지 않음</option>
    </select>
  </label>

  <!-- 실행 버튼 영역 -->
  <div style="margin:12px 0;">
    <button id="runBtn">변경버튼</button>
    <button id="clearBtn">초기화</button>
  </div>

  <!-- 출력 영역: 변환된 결과가 표시되는 읽기 전용 텍스트 영역 -->
  <h3>변경후 출력박스</h3>
  <textarea id="outputQuery" rows="12" cols="120" readonly placeholder="결과가 여기에 표시됩니다."></textarea>

<script>
// ========================================
// 변수 치환 도우미 메인 스크립트
// ========================================
// 전역 스코프 오염 방지를 위한 즉시 실행 함수(IIFE) 사용
(function(){
  // DOM 요소를 ID로 쉽게 가져오기 위한 헬퍼 함수
  const byId = (id) => document.getElementById(id);

  /**
   * parseMappings - 변경 전/후 변수 매핑 파싱 함수
   * @returns {Object} { pairs: 매핑 배열, notice: 불일치 안내 메시지 }
   * 
   * 기능:
   * 1. 두 텍스트 영역에서 줄 단위로 변수를 읽어옴
   * 2. 빈 줄을 제거하고 공백 제거(trim)
   * 3. 같은 줄 번호끼리 1:1 매칭하여 pairs 배열 생성
   * 4. 줄 수가 다르면 경고 메시지 생성
   */
  function parseMappings() {
    // 변경 전 변수: 줄바꿈으로 분리 → 공백 제거 → 빈 줄 필터링
    const before = byId('beforeVars').value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    // 변경 후 변수: 동일한 처리
    const after  = byId('afterVars').value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

    // 두 배열 중 짧은 길이만큼만 매핑 (줄 수가 다를 경우 대비)
    const len = Math.min(before.length, after.length);
    const pairs = [];
    
    // 같은 인덱스(줄 번호)끼리 매칭하여 { from, to } 객체 생성
    for (let i = 0; i < len; i++) {
      pairs.push({from: before[i], to: after[i] ?? ""});
    }

    // 줄 수 불일치 시 안내 메시지 생성
    let notice = "";
    if (before.length !== after.length) {
      notice = `-- 안내: 매핑 줄 수 불일치 (변경전:${before.length}, 변경후:${after.length}) -> 앞에서 ${len}개만 적용됨\n`;
    }
    return {pairs, notice};
  }

  /**
   * escapeRegExp - 정규식 특수 문자 이스케이프 함수
   * @param {string} s - 이스케이프할 문자열
   * @returns {string} 이스케이프된 문자열
   * 
   * 정규식에서 특수한 의미를 가진 문자(. * + ? 등)를 일반 문자로 취급하도록 변환
   */
  function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * makeRegexPattern - 정규식 패턴 생성 함수
   * @param {string} raw - 원본 검색 문자열
   * @param {boolean} useWordBoundary - 단어 경계 사용 여부
   * @returns {RegExp} 생성된 정규식 객체
   * 
   * useWordBoundary가 true면:
   *   - 식별자 앞뒤에 영문자/숫자/밑줄/_콜론(:)이 없는 경우만 매칭
   *   - 예: :OLD를 검색할 때 :OLD_VAR은 매칭되지 않음 (부분 치환 방지)
   */
  function makeRegexPattern(raw, useWordBoundary) {
    const escaped = escapeRegExp(raw);
    
    if (!useWordBoundary) {
      // 단순 전역 치환 모드
      return new RegExp(escaped, regexFlags());
    }
    
    // 식별자를 구성할 수 있는 문자: 영문, 숫자, 밑줄
    const idChar = '[A-Za-z0-9_]';
    // Negative lookbehind: 앞에 식별자 문자나 콜론(:)이 없어야 함
    const boundaryBefore = `(?<!${idChar}|:)`;
    // Negative lookahead: 뒤에 식별자 문자나 콜론(:)이 없어야 함
    const boundaryAfter  = `(?!${idChar}|:)`;
    
    return new RegExp(`${boundaryBefore}${escaped}${boundaryAfter}`, regexFlags());
  }

  /**
   * regexFlags - 정규식 플래그 생성 함수
   * @returns {string} 정규식 플래그 문자열
   * 
   * 'g' (global): 전역 검색 - 첫 번째 매칭만이 아닌 모든 매칭 찾기
   * 'i' (case-insensitive): 대소문자 구분 안 함 (옵션에 따라 추가)
   */
  function regexFlags() {
    const mode = byId('caseMode').value;
    return mode === 'insensitive' ? 'gi' : 'g';
  }

  /**
   * replaceOutsideStrings - 문자열 리터럴 외부만 치환하는 함수
   * @param {string} sql - 입력 SQL 또는 텍스트
   * @param {Array} pairs - {from, to} 매핑 배열
   * @param {boolean} useWordBoundary - 단어 경계 사용 여부
   * @returns {string} 치환된 결과 문자열
   * 
   * 동작 원리:
   * 1. SQL 문자열을 따옴표 문자열('...')과 그 외 부분으로 분리
   *    - 정규식: ('(?:''|[^'])*') 
   *      ▶ ''는 이스케이프된 따옴표, [^']는 따옴표가 아닌 문자
   * 2. 홀수 인덱스(i % 2 === 1)는 문자열 리터럴이므로 건너뜀
   * 3. 짝수 인덱스는 일반 코드 영역이므로 치환 수행
   * 4. 긴 변수명부터 치환 (부분 매칭 문제 방지)
   * 5. 모든 세그먼트를 다시 합쳐서 반환
   */
  function replaceOutsideStrings(sql, pairs, useWordBoundary) {
    // SQL을 따옴표 문자열과 나머지로 분리 (홀수 인덱스 = 문자열 리터럴)
    const segments = sql.split(/('(?:''|[^'])*')/g);
    
    for (let i = 0; i < segments.length; i++) {
      // 홀수 인덱스는 따옴표 안 문자열이므로 치환하지 않음
      if (i % 2 === 1) continue;
      
      // 긴 문자열부터 치환 (짧은 문자열이 긴 문자열의 부분 문자열인 경우 대비)
      const sorted = [...pairs].sort((a, b) => b.from.length - a.from.length);
      let s = segments[i];
      
      // 각 매핑에 대해 치환 수행
      for (const {from, to} of sorted) {
        const re = makeRegexPattern(from, useWordBoundary);
        s = s.replace(re, to);
      }
      segments[i] = s;
    }
    
    // 분리된 세그먼트를 다시 합침
    return segments.join('');
  }

  // ========================================
  // 이벤트 리스너: 변경 버튼 클릭
  // ========================================
  /**
   * 변경 버튼 클릭 시 실행되는 메인 로직
   * 
   * 처리 순서:
   * 1. 입력 쿼리와 매핑 정보 가져오기
   * 2. 매핑이 없으면 안내 메시지 출력 후 종료
   * 3. 옵션 값 읽기 (단어 경계, 문자열 건너뛰기)
   * 4. 옵션에 따라 적절한 치환 방식 선택
   * 5. 결과를 출력 영역에 표시
   */
  byId('runBtn').addEventListener('click', function(){
    // 사용자 입력값 가져오기
    const input = byId('inputQuery').value;
    const {pairs, notice} = parseMappings();

    // 매핑이 비어있으면 안내 메시지 출력
    if (pairs.length === 0) {
      byId('outputQuery').value = '-- 매핑이 없습니다. 변경전/변경후 변수 상자를 채워주세요.\n' + input;
      return;
    }

    // 옵션 값 읽기
    const useBoundary = byId('useWordBoundary').checked;  // 단어 경계 매칭 사용 여부
    const skipStrings = byId('skipStrings').checked;       // 문자열 내부 건너뛰기 여부

    let output;
    
    if (skipStrings) {
      // 옵션1 활성화: 따옴표 문자열 내부는 치환하지 않음
      output = replaceOutsideStrings(input, pairs, useBoundary);
    } else {
      // 옵션1 비활성화: 전체 텍스트에서 치환
      let s = input;
      // 긴 변수명부터 처리 (부분 문자열 문제 방지)
      const sorted = [...pairs].sort((a,b)=>b.from.length - a.from.length);
      for (const {from, to} of sorted) {
        const re = makeRegexPattern(from, useBoundary);
        s = s.replace(re, to);
      }
      output = s;
    }

    // 결과를 출력 영역에 표시 (불일치 안내가 있으면 앞에 추가)
    byId('outputQuery').value = (notice ? notice : '') + output;
  });

  // ========================================
  // 이벤트 리스너: 초기화 버튼 클릭
  // ========================================
  /**
   * 초기화 버튼 클릭 시 모든 입력/출력 영역을 빈 값으로 초기화
   */
  byId('clearBtn').addEventListener('click', function(){
    byId('inputQuery').value = '';   // 입력 쿼리 초기화
    byId('beforeVars').value = '';   // 변경 전 변수 초기화
    byId('afterVars').value = '';    // 변경 후 변수 초기화
    byId('outputQuery').value = '';  // 출력 결과 초기화
  });
  
})(); // 즉시 실행 함수 종료
</script>
</body>
</html>
